# python audit.py /Users/jar/otrepo/files.opentreeoflife.org /Users/jar question: varela:/home/opentree/files.opentreeoflife.org/

artifact_list_path = 'artifact_list.json'

import argparse
p = argparse.ArgumentParser()
p.add_argument("repo", help="root of local files.opentreeoflife.org repo checkout, e.g. '/Users/jar/otrepo/files.opentreeoflife.org'")
p.add_argument("base", help="base directory for local paths, e.g. '/Users/jar'")
p.add_argument("prefix", help="prefix that says a path is relative to base, e.g. 'question:'")
p.add_argument("files", help="location base for files host, e.g. 'http://files.opentreeoflife.org/' or 'varela:/home/opentree/files.opentreeoflife.org/'")

# os.path.realpath(symlink)

# Value of "legal" field:
#   pd = public domain because US govt or out of copyright
#   cc0 = cc0
#   public = distributed to public on web without license
#   handoff = received privately without nondisclosure or license

# sources/    - files that open tree has copied from elsewhere
#   series/
#     versionfile
#     versiondir/
#       file1
#       file2
# targets/    - files generated by open tree
#   series/
#     versionfile
#     versiondir/
#       file1
#       file2

import json, os

# load and validate

allowed_keys = ["name", "retrieved_from", "source_suffix", "target_suffix", "legal", "==="]
series_allowed_keys = allowed_keys + ["versions"]
version_allowed_keys = allowed_keys + ["source", "target"]

def load(artifact_list_path):
    with open(artifact_list_path) as infile:
        directory = json.load(infile)
        for s in directory["series"]:
            for key in s:
                if not key in series_allowed_keys:
                    print '** invalid series field', key
            if "name" in s:
                sname = s["name"]
            else:
                print '** series has no name', s
                continue
            for v in s["versions"]:
                for key in v:
                    if not key in version_allowed_keys:
                        print '** unrecognized key in version', key
                # Inheritance!
                for key in s:
                    if key in allowed_keys and not key in v:
                        v[key] = s[key]
                # default version location is files.opentreeoflife.org/series/version/
                #  which contains artifact files (zips, tarballs)
                if not 'name' in v:
                    print '** artifact has no name', v
                    continue
                vname = v["name"]
                v['series_name'] = sname
                if v.get("source_suffix") == v.get("target_suffix"):
                    print '** suffix clash', v.get("source_suffix"), vname
                if not ("target" in v or "source" in v):
                    print '** artifact should have either source or target', vname
                if "source" in v and not "source_suffix" in v:
                    print '** missing source_suffix', vname
                if "target" in v and not "target_suffix" in v:
                    print '** missing target_suffix', vname
                if "legal" in v:
                    if not v["legal"] in ["pd", "cc0", "public", "handoff"]:
                        print '** unrecognized legal', v["legal"], vname
        return directory

# shuffle bits around to get local artifact store into shape

def audit(artifact_list_path, repo, prefix, local, files_prefix):
    directory = load(artifact_list_path)
    print 'set -e'
    def doit():
        for s in directory["series"]:
            for v in s["versions"]:
                vname = v["name"]
                path = os.path.join(v['series_name'], vname)
                artifacts = []
                if "target" in v:
                    if "target_suffix" in v:
                        fullname = os.path.join(path, vname + v["target_suffix"])
                        artifacts.append((fullname, v["target"], v))
                    else:
                        print '** has no target_suffix', v["name"]
                if "source" in v:
                    fullname = os.path.join(path, vname + v["source_suffix"])
                    legal = v["legal"]
                    if legal in ["pd", "cc0", "public"]:
                        artifacts.append((fullname, v["source"], v))
                    elif legal in ["handoff"]:
                        if len(artifacts) > 0:
                            print 'echo handoff - exporting target only', vname
                        else:
                            print 'echo handoff, no target - not exporting', vname
                    else:
                        print '** unrecognized legal', legal, vname
                for a in artifacts:
                    balance(*a)

    # fullname is relative to local repo clone.
    # exportp says whether it should go on the files server at all.

    def balance(fullname, artifact, v):

        vname = v["name"]

        def local_path(loc):
            path = None
            if not ':' in loc:
                # elsewhere in repo
                return os.path.join(repo, loc)
            elif loc.startswith(prefix):
                # somewhere else on this machine
                return os.path.join(local, loc[len(prefix):])
            else:
                # on the interwebs
                return None

        locations = artifact.get("locations")
        dst = os.path.join(repo, fullname)
        if os.path.exists(dst) and not os.path.islink(dst):
            # print 'echo %s already exists, will not overwrite.' % (dst)
            for loc in locations:
                path = local_path(loc)
                if path != None:
                    if os.path.exists(path):
                        if path == dst:
                            True
                        if os.path.islink(path) or os.path.isdir(path):
                            # Is a symlink or directory - this is the desired state
                            True
                        else:
                            print "echo @@ local path is file or directory, not link:", path
                            print "echo ... for", dst, "which is OK"
                    else:
                        print "echo @@ no such local file or directory:", path
                        print "echo ... for", dst, "which is OK"
            return
        print 'echo --- %s ---' % vname
        if locations == None:
            print '** no locations for this artifact', artifact["name"]
            return
        if len(locations) == 0:
            return
        tbd = None
        local_tbd = None
        for loc in locations: # potential origins
            path = local_path(loc)
            tbd = None
            if path != None:
                if os.path.exists(path):
                    if path == dst:
                        # success (should have been caught earlier)
                        tbd = "echo already have %s !" % (path)
                    elif path.endswith('/') and dst.endswith('.tgz'):
                        dir = path[0:-1]
                        # create tarball, contents = files in path
                        tbd = "./make-tarball %s %s" % (dir, dst)
                    else:
                        # move file and leave symbolic link behind.
                        tbd = "mv %s %s && ln -sf %s %s" % (path, dst, dst, path)
                else:
                    if ':' in loc:
                        print "** no such file", path
                        loc = ""
                    else:
                        print "echo @@ no such file", path
                        print "echo ... might be on files.opentreeoflife.org"
                        loc = files_prefix + loc
            if tbd != None:
                local_tbd = tbd
            else:
                # somewhere on the interwebs
                if '://' in loc:
                    # print 'curl -s -I "%s" | (if ! grep -q 200.OK; then echo Not found: "%s"; fi)' % (loc, loc)
                    tbd = 'curl -s "%s" >%s.tmp && mv %s.tmp %s' % (loc, dst, dst, dst)
                elif ':' in loc:
                    # print "if ! ssh %s test -r %s; then echo Not found: %s; fi" % (loc[0:i], loc[i+1:], loc)
                    tbd = "scp -p %s %s" % (loc, dst)
        if local_tbd != None:
            print "mkdir -p %s" % os.path.dirname(dst)
            print local_tbd
        elif tbd != None:
            print "mkdir -p %s" % os.path.dirname(dst)
            print tbd
        else:
            print "** cannot find", locations
    doit()

args = p.parse_args()

audit(artifact_list_path, args.repo, args.prefix, args.base, args.files)
